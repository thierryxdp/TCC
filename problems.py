def getProblems():
    data_array = []
    
    data_array.append(["def fatorial(n: int) -> int:\n    fat = 1\n    while n>0:\n        fat = fat*n\n        n = n-1\n    return fat\n", "Faça uma função chamada **fatorial** que dado um número, calcule o fatorial deste número. (Não usar a função factorial do módulo math)", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["def intercala(lista1: List[int],lista2: List[int]) -> List[int]:\n    lista3 = 6*[0]\n    lista3[::2] = lista1\n    lista3[1::2] = lista2\n    return lista3\n", "Faça uma função chamada definida por **\\`intercala(lista1, lista2)\\`** que dadas duas listas L1 e L2 de tamanho 3, gera uma lista L3 que é formada intercalando os elementos de L1 e L2. \n\n\n\nExemplo:\n\nL1 = [1, 3, 5] e L2 = [2, 4, 6] gera L3 = [1, 2, 3, 4, 5, 6].", "Listas e Dicionários"])
    # data_array.append(["def posLetra(frase: str, letra: str, ocorrencia: int) -> int:\n    pos = 0\n    contador = 0\n    while pos < len(frase):\n        if frase[pos] == letra:\n            contador = contador + 1\n            if contador == ocorrencia:\n                return pos\n        pos = pos + 1\n    return 'Ocorrência não encontrada'\n", "Faça uma função chamada **posLetra** que recebe como entrada uma string, uma letra, e um número que indica a ocorrência desejada da letra (1 para primeira ocorrência, 2 para segunda, etc). Sua função deve retornar em que posição da string aquela ocorrência da letra está. Caso exista menos ocorrências da letra do que a ocorrência pedida, a função deve mostrar a mensagem \"Ocorrência não encontrada\".\n\nExemplo:\n\n>>> posLetra(\"mariana come banana\", \'a\', 3)\n\n6\n\n(posição da terceira ocorrência da letra \'a\' na string dada)", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["def faltante(pecas: List[int]) -> int:\n    lp = pecas[:]\n    lp.sort()\n    contador = 0\n    peca = -1\n    while (contador < len(lp)):\n        if (lp[contador] == (contador + 1)):\n            contador = contador + 1\n        else:\n            peca = contador + 1\n            contador = len(lp)\n    if (peca == -1):\n        peca = len(lp) + 1\n    return peca\n", "*Questão OBI (Olimpíada Brasileira de Informática - OBI2007, Fase 1, Nível 1) - (Peça Perdida)*\n\nJoãozinho adora quebra-cabeças, essa é sua brincadeira favorita. O grande problema, porém, é que às vezes o jogo vem com uma peça faltando. Isso irrita bastante o pobre menino, que tem de descobrir qual peça está faltando e solicitar uma peça de reposição ao fabricante do jogo. Sabendo que o quebra-cabeças tem N peças, numeradas de 1 a N e que exatamente uma está faltando, ajude Joãozinho a saber qual peça ele tem de pedir.\n\nEscreva uma função chamada **faltante** que, dada uma lista com N − 1 inteiros numerados de 1 a N, descubra qual número inteiro deste intervalo está faltando.\n\n- **Entrada:** O parâmetro de entrada é uma lista L de tamanho N − 1 contendo números inteiros (não repetidos) de 1 a N.\n- **Saída:** A sua função deve retornar o número inteiro x que pertence ao intervalo [1, N] mas que não pertence a lista de entrada L.\n\nExemplos:\n\n- Entrada: [3,1];\nSaída: 2\n- Entrada: [1,2,3,5] ;\nSaída: 4\n- Entrada: [2,4,3] ;\nSaída: 1", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["def bolo(a: int,b: int,c: int) -> int:\n    return min(a//2,b//3,c//5)\n", "*Questão OBI (Olimpíada Brasileira de Informática - OBI2012, Fase 2, Nível Júnior) - (Receita de Bolo)*\n\nJoão deseja fazer bolos para seus amigos, usando uma receita que indica que devem ser usadas 2 xícaras de farinha de trigo, 3 ovos e 5 colheres de sopa de leite.\nEm casa ele tem **A** xícaras de farinha de trigo, **B** ovos e **C** colheres de sopa de leite. João não tem muita prática com a cozinha, e portanto ele só se arriscará a\nfazer medidas exatas da receita de bolo (por exemplo, se ele tiver material suficiente para fazer mais do que 2 e menos do que 3 bolos, ele fará somente 2 bolos). \nSabendo disto, ajude João escrevendo uma função chamada **bolos** que determine qual a quantidade máxima de bolos que ele consegue fazer.\n\n- **Entrada:** Os parâmetros de entrada da função são três números inteiros A, B e C, indicando respectivamente o número de xícaras de farinha de trigo, o número de ovos e o número de colheres de sopa de leite que João tem em casa.\n\n- **Saída:** Sua função deve retornar a quantidade máxima de bolos que João consegue fazer.\n\nExemplos:\n\n- Entrada: 4, 6, 10;\nSaída: 2\n- Entrada: 4, 6, 9 ;\nSaída: 1'", "Funcoes e Tipos de dados"])
    # data_array.append(["def freq_palavras(frase: str) -> dict:\n    if not re.fullmatch(\"((another)|(value)|(test)| )*\", frase):\n        return None\n    dic = {}\n    lista = frase.split()\n    for palavra in lista:\n        if palavra in dic:\n            dic[palavra] += 1\n        else:\n            dic[palavra] = 1\n    return dic\n", "Construa uma função chamada **freq_palavras(frases)** que receba uma string e retorne um dicionário onde cada palavra dessa string seja uma chave e tenha como valor o número de vezes que a palavra aparece. Por exemplo: \n\n- freq_palavras(\"dinheiro é dinheiro e vice versa\") \n\nRetorna o dicionário: { \"dinheiro\":2, \"é\": 1, \"e\": 1, \"vice\": 1, \"versa\":1}", "Estrutura de repetição iteradora: for"])
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    # my_data_object.add_data_row("method", "context", "theme")
    return data_array