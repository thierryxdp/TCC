def getProblems():
    data_array = []
    
    # 02 - Funções e Tipos de dados
    # data_array.append(["def num_bombons(m, p):\n    return m//p\n", "Pedrinho quer comprar o maior número de bombons possível com o dinheiro que tem. Faça uma função chamada num_bombons para calcular quantos bombons ele consegue comprar, dados o dinheiro e o preço do bombom para realização da compra.", "Funções e Tipos de dados", ['def test_case_1():\n    assert num_bombons(48.24, 5.35) == 9.0\n', 'def test_case_2():\n    assert num_bombons(79.96, 1.43) == 55.0\n', 'def test_case_3():\n    assert num_bombons(72.35, 9.93) == 7.0\n', 'def test_case_4():\n    assert num_bombons(88.18, 1.36) == 64.0\n', 'def test_case_5():\n    assert num_bombons(53.28, 1.47) == 36.0\n', 'def test_case_6():\n    assert num_bombons(8.61, 0.7) == 12.0\n', 'def test_case_7():\n    assert num_bombons(27.72, 4.2) == 6.0\n', 'def test_case_8():\n    assert num_bombons(52.33, 3.89) == 13.0\n', 'def test_case_9():\n    assert num_bombons(0, 0.1) == 0.0\n', 'def test_case_10():\n    assert num_bombons(1.0, 0.5) == 2.0\n']])
    # data_array.append(["def carros(passageiros: int,capacidade) -> int:\n    return math.ceil(passageiros/capacidade)\n", "Um grupo de amigos deseja fazer uma viagem e decidiram ir de carro. Pelas regras rodoviárias um veículo convencional tem a capacidade de transportar até 5 passageiros, porém há veículos com outras capacidades. Construa uma função em Python chamada carros para calcular e retornar o número exato de carros necessários para esta viagem, considerando que seja dado como entrada o número de pessoas. Caso os veículos considerados sejam de capacidades não convencionais, será dado também como entrada a capacidade dos veículos, considerando que todos os veículos são iguais.", "Funções e Tipos de dados", ['def test_case_1():\n    assert carros(12) == 3\n', 'def test_case_2():\n    assert carros(1) == 1\n', 'def test_case_3():\n    assert carros(16) == 4\n', 'def test_case_4():\n    assert carros(3, 1) == 3\n', 'def test_case_5():\n    assert carros(1, 3) == 1\n', 'def test_case_6():\n    assert carros(16, 6) == 3\n', 'def test_case_7():\n    assert carros(14, 4) == 4\n', 'def test_case_8():\n    assert carros(11, 6) == 2\n', 'def test_case_9():\n    assert carros(0) == 0\n', 'def test_case_10():\n    assert carros(5) == 1\n']])
    # data_array.append(["def bolo(a: int,b: int,c: int) -> int:\n    return min(a//2,b//3,c//5)\n", "*Questão OBI (Olimpíada Brasileira de Informática - OBI2012, Fase 2, Nível Júnior) - (Receita de Bolo)*\n\nJoão deseja fazer bolos para seus amigos, usando uma receita que indica que devem ser usadas 2 xícaras de farinha de trigo, 3 ovos e 5 colheres de sopa de leite.\nEm casa ele tem **A** xícaras de farinha de trigo, **B** ovos e **C** colheres de sopa de leite. João não tem muita prática com a cozinha, e portanto ele só se arriscará a\nfazer medidas exatas da receita de bolo (por exemplo, se ele tiver material suficiente para fazer mais do que 2 e menos do que 3 bolos, ele fará somente 2 bolos). \nSabendo disto, ajude João escrevendo uma função chamada **bolos** que determine qual a quantidade máxima de bolos que ele consegue fazer.\n\n- **Entrada:** Os parâmetros de entrada da função são três números inteiros A, B e C, indicando respectivamente o número de xícaras de farinha de trigo, o número de ovos e o número de colheres de sopa de leite que João tem em casa.\n\n- **Saída:** Sua função deve retornar a quantidade máxima de bolos que João consegue fazer.\n\nExemplos:\n\n- Entrada: 4, 6, 10;\nSaída: 2\n- Entrada: 4, 6, 9 ;\nSaída: 1'", "Funcoes e Tipos de dados", ['def test_case_1():\n    assert bolo(2, 50, 3) == 0\n', 'def test_case_2():\n    assert bolo(2, 3, 5) == 1\n', 'def test_case_3():\n    assert bolo(6, 9, 15) == 3\n', 'def test_case_4():\n    assert bolo(2, 6, 50) == 1\n', 'def test_case_5():\n    assert bolo(20, 15, 500) == 5\n', 'def test_case_6():\n    assert bolo(20, 15, 10) == 2\n', 'def test_case_7():\n    assert bolo(4, 6, 10) == 2\n', 'def test_case_8():\n    assert bolo(4, 6, 9) == 1\n', 'def test_case_9():\n    assert bolo(0, 5, 5) == 0\n', 'def test_case_10():\n    assert bolo(10, 1, 5) == 0\n']])
    
    # 03 - Tipos de dados, Strings, Estrutura Condicional
    # data_array.append(["def PosNegZero(x: int) -> str:\n    if x > 0:\n        return str(x) + ' e positivo'\n    if x < 0:\n        return str(x) + ' e negativo'\n    return str(x) + ' e zero'\n", "Faça uma função chamada PosNegZero que determina se um número inteiro X passado como parâmetro é positivo, negativo ou zero. O valor de retorno da função deve ser uma dentre as strings “X e positivo”, “X e negativo” ou “X e zero”.", "Tipos de dados, Strings, Estrutura Condicional", ["def test_case_1():\n    assert PosNegZero(51) == '51 e positivo'\n", "def test_case_2():\n    assert PosNegZero(-71) == '-71 e negativo'\n", "def test_case_3():\n    assert PosNegZero(-45) == '-45 e negativo'\n", "def test_case_4():\n    assert PosNegZero(-47) == '-47 e negativo'\n", "def test_case_5():\n    assert PosNegZero(44) == '44 e positivo'\n", "def test_case_6():\n    assert PosNegZero(-27) == '-27 e negativo'\n", "def test_case_7():\n    assert PosNegZero(-4) == '-4 e negativo'\n", "def test_case_8():\n    assert PosNegZero(71) == '71 e positivo'\n", "def test_case_9():\n    assert PosNegZero(12) == '12 e positivo'\n", "def test_case_10():\n    assert PosNegZero(73) == '73 e positivo'\n", "def test_case_11():\n    assert PosNegZero(30) == '30 e positivo'\n", "def test_case_12():\n    assert PosNegZero(-66) == '-66 e negativo'\n", "def test_case_13():\n    assert PosNegZero(-49) == '-49 e negativo'\n", "def test_case_14():\n    assert PosNegZero(-23) == '-23 e negativo'\n", "def test_case_15():\n    assert PosNegZero(18) == '18 e positivo'\n", "def test_case_16():\n    assert PosNegZero(50) == '50 e positivo'\n", "def test_case_17():\n    assert PosNegZero(40) == '40 e positivo'\n", "def test_case_18():\n    assert PosNegZero(-26) == '-26 e negativo'\n", "def test_case_19():\n    assert PosNegZero(-16) == '-16 e negativo'\n", "def test_case_20():\n    assert PosNegZero(-73) == '-73 e negativo'\n", "def test_case_21():\n    assert PosNegZero(-75) == '-75 e negativo'\n", "def test_case_22():\n    assert PosNegZero(3) == '3 e positivo'\n", "def test_case_23():\n    assert PosNegZero(-75) == '-75 e negativo'\n", "def test_case_24():\n    assert PosNegZero(10) == '10 e positivo'\n", "def test_case_25():\n    assert PosNegZero(31) == '31 e positivo'\n", "def test_case_26():\n    assert PosNegZero(6) == '6 e positivo'\n", "def test_case_27():\n    assert PosNegZero(51) == '51 e positivo'\n", "def test_case_28():\n    assert PosNegZero(28) == '28 e positivo'\n", "def test_case_29():\n    assert PosNegZero(47) == '47 e positivo'\n", "def test_case_30():\n    assert PosNegZero(48) == '48 e positivo'\n", "def test_case_31():\n    assert PosNegZero(34) == '34 e positivo'\n", "def test_case_32():\n    assert PosNegZero(43) == '43 e positivo'\n", "def test_case_33():\n    assert PosNegZero(28) == '28 e positivo'\n", "def test_case_34():\n    assert PosNegZero(38) == '38 e positivo'\n", "def test_case_35():\n    assert PosNegZero(-74) == '-74 e negativo'\n", "def test_case_36():\n    assert PosNegZero(14) == '14 e positivo'\n", "def test_case_37():\n    assert PosNegZero(14) == '14 e positivo'\n", "def test_case_38():\n    assert PosNegZero(24) == '24 e positivo'\n", "def test_case_39():\n    assert PosNegZero(21) == '21 e positivo'\n", "def test_case_40():\n    assert PosNegZero(41) == '41 e positivo'\n", "def test_case_41():\n    assert PosNegZero(76) == '76 e positivo'\n", "def test_case_42():\n    assert PosNegZero(-79) == '-79 e negativo'\n", "def test_case_43():\n    assert PosNegZero(64) == '64 e positivo'\n", "def test_case_44():\n    assert PosNegZero(-28) == '-28 e negativo'\n", "def test_case_45():\n    assert PosNegZero(-67) == '-67 e negativo'\n", "def test_case_46():\n    assert PosNegZero(-64) == '-64 e negativo'\n", "def test_case_47():\n    assert PosNegZero(49) == '49 e positivo'\n", "def test_case_48():\n    assert PosNegZero(0) == '0 e zero'\n", "def test_case_49():\n    assert PosNegZero(-27) == '-27 e negativo'\n", "def test_case_50():\n    assert PosNegZero(8) == '8 e positivo'\n", "def test_case_51():\n    assert PosNegZero(-43) == '-43 e negativo'\n"]])
    # data_array.append(["def classificacao(Cv: int, Ce: int, Cs: int, Fv: int, Fe: int, Fs: int) -> str:\n    if Cv * 3 + Ce > Fv * 3 + Fe:\n        return 'Cormengo'\n    if Cv * 3 + Ce < Fv * 3 + Fe:\n        return 'Flaminthians'\n    if Cs > Fs:\n        return 'Cormengo'\n    if Cs < Fs:\n        return 'Flaminthians'\n    return 'Empate'\n", "Dois times, Cormengo e Flaminthians, participam de um campeonato de futebol, juntamente com outros times. Cada vitória conta três pontos, cada empate um ponto. Fica melhor classificado no campeonato um time que tenha mais pontos. Em caso de empate no número de pontos, fica melhor classificado o time que tiver maior saldo de gols. Se o número de pontos e o saldo de gols forem os mesmos para os dois times então os dois times estão empatados no campeonato. Faça uma função definida por classificacao(Cv, Ce, Cs, Fv, Fe, Fs). Dados os números de vitórias e empates, e os saldos de gols dos dois times, sua tarefa é determinar qual dos dois está melhor classificado, ou se eles estão empatados no campeonato.Entrada: Os parâmetros de entrada da função são seis números inteiros C, Ce, Cs, F v, F e e F s, que são, respectivamente, o número de vitórias do Cormengo, o número de empates do Cormengo, o saldo de gols do Cormengo, o número de vitórias do Flaminthians, o número de empates do Flaminthians e o saldo de gols do Flaminthians. Saída: A sua fun¸ção deve retornar a string 'Cormengo', se Cormengo estiver melhor classificado que Flaminthians ou a string 'Flaminthians' , se Flaminthians estiver melhor classificado que Cormengo; e se os dois times estão empatados a função deve retornar 'Empate'. Exemplos: Entrada: 10,5,18,11,2,18 Saída: ’Empate’\nEntrada: 10,5,18,11,1,18 ; Saída: ’Cormengo’\nEntrada: 9,5,-1,10,2,10 Saída: ’Flaminthians’", "Tipos de dados, Strings, Estrutura Condicional", ["def test_case_1():\n    assert classificacao(9, 5, 6, 18, 5, 0) == 'Flaminthians'\n", "def test_case_2():\n    assert classificacao(5, 6, 6, 9, 19, 7) == 'Flaminthians'\n", "def test_case_3():\n    assert classificacao(9, 2, -3, 9, 2, -3) == 'Empate'\n", "def test_case_4():\n    assert classificacao(11, 13, -8, 10, 12, -9) == 'Cormengo'\n", "def test_case_5():\n    assert classificacao(19, 4, 4, 8, 7, 2) == 'Cormengo'\n", "def test_case_6():\n    assert classificacao(9, 17, 0, 13, 16, 6) == 'Flaminthians'\n", "def test_case_7():\n    assert classificacao(15, 2, 2, 11, 9, 7) == 'Cormengo'\n", "def test_case_8():\n    assert classificacao(18, 7, 9, 9, 6, -5) == 'Cormengo'\n", "def test_case_9():\n    assert classificacao(3, 16, -1, 18, 10, -2) == 'Flaminthians'\n", "def test_case_10():\n    assert classificacao(14, 15, -4, 7, 9, 5) == 'Cormengo'\n", "def test_case_11():\n    assert classificacao(16, 5, -5, 13, 3, -8) == 'Cormengo'\n", "def test_case_12():\n    assert classificacao(18, 6, 6, 2, 54, 6) == 'Empate'\n", "def test_case_13():\n    assert classificacao(16, 2, -2, 19, 3, -3) == 'Flaminthians'\n", "def test_case_14():\n    assert classificacao(6, 2, 6, 2, 14, 6) == 'Empate'\n", "def test_case_15():\n    assert classificacao(10, 19, -5, 8, 25, -9) == 'Cormengo'\n", "def test_case_16():\n    assert classificacao(18, 8, -3, 17, 11, 6) == 'Flaminthians'\n", "def test_case_17():\n    assert classificacao(16, 11, 6, 3, 5, -10) == 'Cormengo'\n", "def test_case_18():\n    assert classificacao(1, 12, 2, 10, 26, 2) == 'Flaminthians'\n", "def test_case_19():\n    assert classificacao(19, 2, -9, 3, 4, 8) == 'Cormengo'\n", "def test_case_20():\n    assert classificacao(17, 6, -2, 10, 27, 8) == 'Flaminthians'\n", "def test_case_21():\n    assert classificacao(16, 4, 6, 16, 4, 6) == 'Empate'\n", "def test_case_22():\n    assert classificacao(0, 27, -9, 2, 21, -9) == 'Empate'\n", "def test_case_23():\n    assert classificacao(12, 5, 9, 13, 2, 4) == 'Cormengo'\n", "def test_case_24():\n    assert classificacao(15, 14, -7, 17, 8, -7) == 'Empate'\n", "def test_case_25():\n    assert classificacao(15, 11, 2, 13, 17, -5) == 'Cormengo'\n", "def test_case_26():\n    assert classificacao(6, 8, -5, 8, 2, 9) == 'Flaminthians'\n", "def test_case_27():\n    assert classificacao(2, 28, -5, 12, 21, -8) == 'Flaminthians'\n", "def test_case_28():\n    assert classificacao(13, 5, -10, 5, 29, 9) == 'Flaminthians'\n", "def test_case_29():\n    assert classificacao(15, 15, 5, 7, 6, -9) == 'Cormengo'\n", "def test_case_30():\n    assert classificacao(2, 20, -9, 14, 5, 8) == 'Flaminthians'\n", "def test_case_31():\n    assert classificacao(14, 2, 0, 17, 14, 0) == 'Flaminthians'\n", "def test_case_32():\n    assert classificacao(18, 8, 6, 3, 11, -5) == 'Cormengo'\n", "def test_case_33():\n    assert classificacao(7, 23, 3, 9, 17, 3) == 'Empate'\n", "def test_case_34():\n    assert classificacao(10, 6, -6, 10, 2, 9) == 'Cormengo'\n", "def test_case_35():\n    assert classificacao(14, 4, 3, 15, 1, 3) == 'Empate'\n", "def test_case_36():\n    assert classificacao(7, 23, 4, 5, 13, 2) == 'Cormengo'\n", "def test_case_37():\n    assert classificacao(4, 19, 4, 6, 13, 4) == 'Empate'\n", "def test_case_38():\n    assert classificacao(5, 16, 2, 1, 10, 8) == 'Cormengo'\n", "def test_case_39():\n    assert classificacao(10, 18, 7, 9, 21, 7) == 'Empate'\n", "def test_case_40():\n    assert classificacao(8, 8, -8, 7, 11, -8) == 'Empate'\n", "def test_case_41():\n    assert classificacao(11, 5, 9, 16, 2, 7) == 'Flaminthians'\n", "def test_case_42():\n    assert classificacao(14, 12, 3, 13, 15, 3) == 'Empate'\n", "def test_case_43():\n    assert classificacao(1, 9, 0, 1, 11, -10) == 'Flaminthians'\n", "def test_case_44():\n    assert classificacao(16, 4, -3, 15, 7, -3) == 'Empate'\n", "def test_case_45():\n    assert classificacao(8, 8, -10, 13, 13, 4) == 'Flaminthians'\n", "def test_case_46():\n    assert classificacao(12, 18, 0, 11, 14, 8) == 'Cormengo'\n", "def test_case_47():\n    assert classificacao(18, 2, 0, 13, 17, 0) == 'Empate'\n", "def test_case_48():\n    assert classificacao(5, 5, 4, 3, 11, 9) == 'Flaminthians'\n", "def test_case_49():\n    assert classificacao(15, 1, -2, 11, 13, -2) == 'Empate'\n", "def test_case_50():\n    assert classificacao(6, 18, 9, 9, 9, 9) == 'Empate'\n"]])
    # data_array.append(["def avioes(competidores: int, quantidadePapel: int, quantidadeFolhas: int) -> str:\n    if quantidadePapel//(competidores*quantidadeFolhas) == 0:\n        return 'Insuficiente'\n    return 'Suficiente'\n", "Para descontrair os alunos após as provas da OBI, a Diretora da escola organizou um campeonato de aviões de papel. Cada aluno participante receberá uma certa quantidade de folhas de um papel especial para fazer os seus modelos de aviões. A quantidade de folhas que cada aluno deverá receber ainda não foi determinada: ela será decidida pelos juízes do campeonato. A diretora convidou, para atuarem como juízes, engenheiros da Embraer, uma das mais bem sucedidas empresas brasileiras, que vende aviões com tecnologia brasileira no mundo todo. O campeonato está programado para começar logo após a prova da OBI, mas os juízes ainda não chegaram à escola. A diretora está aflita, pois comprou uma boa quantidade de folhas de papel especial, mas não sabe se a quantidade comprada vai ser suficiente. Considere, por exemplo, que a Diretora comprou 100 folhas de papel especial, e que há 33 competidores. Se os juízes decidirem que cada competidor tem direito a três folhas de papel, a quantidade comprada pela diretora é suficiente. Mas se os juízes decidirem que cada competidor tem direito a quatro folhas, a quantidade comprada pela diretora não seria suficiente. Você deve escrever uma função definida por avioes(competidores, papel comprado, papel competidor) que, dados o número de competidores, o número de folhas de papel especial compradas pela Diretora e o número de folhas que cada competidor deve receber, determine se o número de folhas comprado pela Diretora é suficiente. Entrada: Os parâmetros de entrada da função são três números inteiros representando respectivamente o número de competidores, a quantidade de folhas de papel especial compradas pela Diretora e a quantidade de folhas de papel especial que cada competidor deve receber. Saída: A sua função deve retornar 'Suficiente' se a quantidade de folhas compradas pela Diretora for suficiente, ou 'Insuficiente' caso contrário. Exemplos: Entrada: 10,100,10 Saída: 'Suficiente'\nEntrada: 10,90,10Saída: 'Insuficiente'\nEntrada: 5,40,2Saída: 'Suficiente'", "Tipos de dados, Strings, Estrutura Condicional", ])
    
    # 04 - Variáveis e atribuição, strings e tuplas
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    
    # 05 - Manipulação de strings, tuplas e listas
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    
    # 06 - Fatiamento e manipulação de listas
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    
    # 07 - Estrutura de repetição com teste de parada: While
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    
    # 08 - Estrutura de repetição iteradora: for
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    
    # 09 - Laços aninhados e matrizes
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    
    # 05 - Listas e Dicionários
    # data_array.append(["def intercala(lista1: List[int],lista2: List[int]) -> List[int]:\n    lista3 = 6*[0]\n    lista3[::2] = lista1\n    lista3[1::2] = lista2\n    return lista3\n", "Faça uma função chamada definida por **\\`intercala(lista1, lista2)\\`** que dadas duas listas L1 e L2 de tamanho 3, gera uma lista L3 que é formada intercalando os elementos de L1 e L2. \n\n\n\nExemplo:\n\nL1 = [1, 3, 5] e L2 = [2, 4, 6] gera L3 = [1, 2, 3, 4, 5, 6].", "Listas e Dicionários"])
    # data_array.append(["def pontos_por_time(jogos: list[list[str, str, list[int, int]]]) -> dict[str, int]:\n    pontuacao = {}\n    \n    for jogo in jogos:\n        time1 = jogo[0]\n        time2 = jogo[1]\n        if time1 not in pontuacao:\n            pontuacao[time1] = 0\n        if time2 not in pontuacao:\n            pontuacao[time2] = 0\n            \n        resultado = jogo[2]\n        if resultado[0] > resultado[1]:\n            pontuacao[time1] += 3\n        elif resultado[0] < resultado[1]:\n            pontuacao[time2] += 3\n        else:\n            pontuacao[time1] += 1\n            pontuacao[time2] += 1\n            \n    return pontuacao\n", "Faça uma função chamada pontos_por_time  que receba uma lista de dois elementos, onde cada elemento é também uma lista. A lista completa tem informações do número de gols em dois jogos de futebol entre dois times (jogo da ida e jogo da volta), no seguinte formato: [['Cormengo', 'Flamínthians', [1, 0]], ['Flamínthians', 'Cormengo', [2, 2]]].Nesta lista de exemplo, no primeiro jogo entre Cormengo e Flamínthians, o Cormengo fez 1 gol e o Flamínthians não fez gol. Sua função deve retornar um dicionário cujos mapeamentos são: <nome do time>  -> <numero total de pontos na fase>. Os pontos de um time na fase são calculados da seguinte forma: em cada jogo, os times recebem três pontos por vitória e um ponto por empate. Não são atribuídos pontos para derrotas. O total de pontos de uma fase é a soma de pontos dos dois jogos da fase. Na lista de exemplo, o total de pontos do Cormengo é 4 e do Flamínthians é 1.", "Listas e Dicionários"])
    # data_array.append(["def colchao(lista: list[int],H: int,L: int) -> bool:\n    maior = max(L,H)\n    menor = min(L,H)\n    if lista[1] > maior:\n        return False\n    else:\n        if lista[0] > menor:\n            return False\n        else:\n            return True\n", "Questão OBI (Olimpíada Brasileira de Informática - OBI2012, Fase 1, Nível 2) - (Colchão)\n\nJoão está comprando móveis novos para sua casa. Agora é a vez de comprar um colchão novo, de molas, para substituir o colchão velho. As portas de sua casa têm altura H e largura L e existe um colchão que está em promoção com dimensões A × B × C. O colchão tem a forma de um paralelepípedo reto retângulo e João só consegue arrastá-lo através de uma porta com uma de suas faces paralelas ao chão, mas consegue virar e rotacionar o colchão antes de passar pela porta. Entretanto, de nada adianta ele comprar o colchão se ele não passar através das portas de sua casa. Portanto ele quer saber se consegue passar o colchão pelas portas e para isso precisa de sua ajuda. Faça uma função definida por colchao(medidas,H,L) para resolver esse problema, onde medidas é uma lista com os tamanhos inteiros A, B e C, e H e L são os tamanhos inteiros da altura e largura da porta, respectivamente.\nEntrada: Os parâmetros de entrada são uma lista com as dimensões do colchão em centímetros, ordenadas da menor para a maior, e dois inteiros H e L, correspondentes respectivamente a altura e a largura das portas em centímetros.\nSaída: A sua função deve retornar True se o colchão passa pelas portas e False caso contrário.\nExemplos:\nEntrada: [25,120,220], 200, 100 ; Saída: True\nEntrada: [25,205,220], 200, 100 ; Saída: False\nEntrada: [25,200,220], 200, 100 ; Saída: True", "Listas e Dicionários"])
    
    # (DES) 08 - Estrutura de Repetição - for
    # data_array.append(["def soma_h(n: int) -> float:\n    soma = 0\n    for denominador in range(1,n+1):\n        soma += 1.0/denominador\n    return round(soma,2)", "Faça uma função chamada soma_h para calcular e retornar o valor H com N termos onde N é inteiro e dado com entrada. Retorne seu resultado somente com 2 casas decimais, utilizando a função round(número, 2)", "Estrutura de repetição iteradora: for"])
    # data_array.append(["def divisores(n: int) -> int:\n    total = 0\n    for contador in range(1,n+1):\n        if n%contador == 0:\n            total += 1\n    return total", "Faça uma função chamada divisores que conte quantos divisores um número tem. Este número será passado como argumento de entrada. Exemplo: Se o número for 10, os divisores são: 1, 2, 5 e 10; total de 4 divisores.", "Estrutura de repetição iteradora: for"])
    # data_array.append(["def freq_palavras(frase: str) -> dict:\n    if not re.fullmatch(\"((another)|(value)|(test)| )*\", frase):\n        return None\n    dic = {}\n    lista = frase.split()\n    for palavra in lista:\n        if palavra in dic:\n            dic[palavra] += 1\n        else:\n            dic[palavra] = 1\n    return dic\n", "Construa uma função chamada **freq_palavras(frases)** que receba uma string e retorne um dicionário onde cada palavra dessa string seja uma chave e tenha como valor o número de vezes que a palavra aparece. Por exemplo: \n\n- freq_palavras(\"dinheiro é dinheiro e vice versa\") \n\nRetorna o dicionário: { \"dinheiro\":2, \"é\": 1, \"e\": 1, \"vice\": 1, \"versa\":1}", "Estrutura de repetição iteradora: for"])
    # data_array.append(["def lingua_p(palavra: str) -> str:\n    palavra = str.lower(palavra)\n    traduzida = ''\n    for c in palavra:\n        traduzida = traduzida + c\n        if c in 'aeiouáàãâéêíóòõú':\n            traduzida = traduzida + 'p' + c\n    return traduzida\n", "Faça uma função chamada lingua_p que receba como parâmetro uma palavra e retorne esta mesma palavra traduzida para a lingua do P. Uma palavra é traduzida para a lingua do P quando, após cada vogal da palavra original, é inserida a sequencia de letras p mais a vogal original.\n\nPor exemplo:\n\nexemplo → epexepemplopo\n\nentao → epentapaopo\n\ncaderno → capadepernopo", "Estrutura de repetição iteradora: for"])
    # data_array.append(["def count(frase: str, letra: str) -> int:\n    contador = 0\n    for l in frase.lower():\n        if letra == l:\n            contador += 1\n    return contador", "Faça uma função chamada count  que dada uma frase e uma letra, conte quantas vezes aquela letra aparece na frase, só que sem usar a função count()\nAtenção!Maiúsculas e minúsculas também contam! Mas o computador não sabe que elas são iguais, você precisa antes transformá-las!", "Estrutura de repetição iteradora: for"])
    
    # data_array.append(["def fatorial(n: int) -> int:\n    fat = 1\n    while n>0:\n        fat = fat*n\n        n = n-1\n    return fat\n", "Faça uma função chamada **fatorial** que dado um número, calcule o fatorial deste número. (Não usar a função factorial do módulo math)", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["def posLetra(frase: str, letra: str, ocorrencia: int) -> int:\n    pos = 0\n    contador = 0\n    while pos < len(frase):\n        if frase[pos] == letra:\n            contador = contador + 1\n            if contador == ocorrencia:\n                return pos\n        pos = pos + 1\n    return 'Ocorrência não encontrada'\n", "Faça uma função chamada **posLetra** que recebe como entrada uma string, uma letra, e um número que indica a ocorrência desejada da letra (1 para primeira ocorrência, 2 para segunda, etc). Sua função deve retornar em que posição da string aquela ocorrência da letra está. Caso exista menos ocorrências da letra do que a ocorrência pedida, a função deve mostrar a mensagem \"Ocorrência não encontrada\".\n\nExemplo:\n\n>>> posLetra(\"mariana come banana\", \'a\', 3)\n\n6\n\n(posição da terceira ocorrência da letra \'a\' na string dada)", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["def faltante(pecas: List[int]) -> int:\n    lp = pecas[:]\n    lp.sort()\n    contador = 0\n    peca = -1\n    while (contador < len(lp)):\n        if (lp[contador] == (contador + 1)):\n            contador = contador + 1\n        else:\n            peca = contador + 1\n            contador = len(lp)\n    if (peca == -1):\n        peca = len(lp) + 1\n    return peca\n", "*Questão OBI (Olimpíada Brasileira de Informática - OBI2007, Fase 1, Nível 1) - (Peça Perdida)*\n\nJoãozinho adora quebra-cabeças, essa é sua brincadeira favorita. O grande problema, porém, é que às vezes o jogo vem com uma peça faltando. Isso irrita bastante o pobre menino, que tem de descobrir qual peça está faltando e solicitar uma peça de reposição ao fabricante do jogo. Sabendo que o quebra-cabeças tem N peças, numeradas de 1 a N e que exatamente uma está faltando, ajude Joãozinho a saber qual peça ele tem de pedir.\n\nEscreva uma função chamada **faltante** que, dada uma lista com N − 1 inteiros numerados de 1 a N, descubra qual número inteiro deste intervalo está faltando.\n\n- **Entrada:** O parâmetro de entrada é uma lista L de tamanho N − 1 contendo números inteiros (não repetidos) de 1 a N.\n- **Saída:** A sua função deve retornar o número inteiro x que pertence ao intervalo [1, N] mas que não pertence a lista de entrada L.\n\nExemplos:\n\n- Entrada: [3,1];\nSaída: 2\n- Entrada: [1,2,3,5] ;\nSaída: 4\n- Entrada: [2,4,3] ;\nSaída: 1", "Estrutura de repetição com teste de parada: While"])
    
    # data_array.append(["def total(compras: List[int], produtos: Dict[str, float]) -> float:\n    soma = 0\n    for produto in compras:\n        if produto in produtos:\n            soma += produtos[produto]\n    return round(soma,2)", "Escreva uma função chamada total que recebe uma lista de compras e um dicionário contendo o preço de cada produto disponível em uma determinada loja, e retorna o valor total dos itens da lista que estejam disponíveis nesta loja. Por exemplo, para os dados:\nlista de compras = [’biscoito’, ’chocolate’, ’farinha’]\nprodutos = { ’amaciante’:4.99, ’arroz’:10.90, ’biscoito’:1.69, ’cafe’:6.98, ’chocolate’:3.79, ’farinha’:2.99 } \nO valor retornado pela função será 8.47. Retorne seu resultado somente com 2 casas decimais, utilizando a função round(número, 2).", "Dicionário"])
    # data_array.append(["def insere(lista: List[int], n: int) -> List[int]:\n    lista=lista+[n]\n    return sorted(lista)", "Faça uma função definida por insere(lista_numero, n) que dada uma lista ordenada (crescente) de números inteiros e um número inteiro n, inclua n na posição correta. Retorne a lista atualizada.", "Listas"])
    # data_array.append(["def maiores(lista: List[int], n: int):\n    lista = lista+[n]\n    list.sort(lista)\n    list.reverse(lista)\n    indice=list.index(lista,n)\n    sublista=lista[:indice]\n    list.sort(sublista)\n    list.reverse(sublista)\n    return str(sublista)", "Faça uma função chamada maiores que dada uma lista ordenada L (decrescente) de números inteiros e um número inteiro n, retorne a sublista formada por todos os elementos maiores que n em ordem decrescente.", "Listas"])
    
    
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    return data_array