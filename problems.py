def getProblems():
    data_array = []
    
    # 02 - Funções e Tipos de dados
    # data_array.append(["def num_bombons(m, p):\n    return m//p\n", "Pedrinho quer comprar o maior número de bombons possível com o dinheiro que tem. Faça uma função chamada num_bombons para calcular quantos bombons ele consegue comprar, dados o dinheiro e o preço do bombom para realização da compra.", "Funções e Tipos de dados", ['def test_case_1():\n    assert num_bombons(48.24, 5.35) == 9.0\n', 'def test_case_2():\n    assert num_bombons(79.96, 1.43) == 55.0\n', 'def test_case_3():\n    assert num_bombons(72.35, 9.93) == 7.0\n', 'def test_case_4():\n    assert num_bombons(88.18, 1.36) == 64.0\n', 'def test_case_5():\n    assert num_bombons(53.28, 1.47) == 36.0\n', 'def test_case_6():\n    assert num_bombons(8.61, 0.7) == 12.0\n', 'def test_case_7():\n    assert num_bombons(27.72, 4.2) == 6.0\n', 'def test_case_8():\n    assert num_bombons(52.33, 3.89) == 13.0\n', 'def test_case_9():\n    assert num_bombons(0, 0.1) == 0.0\n', 'def test_case_10():\n    assert num_bombons(1.0, 0.5) == 2.0\n']])
    # data_array.append(["def carros(passageiros: int,capacidade) -> int:\n    return math.ceil(passageiros/capacidade)\n", "Um grupo de amigos deseja fazer uma viagem e decidiram ir de carro. Pelas regras rodoviárias um veículo convencional tem a capacidade de transportar até 5 passageiros, porém há veículos com outras capacidades. Construa uma função em Python chamada carros para calcular e retornar o número exato de carros necessários para esta viagem, considerando que seja dado como entrada o número de pessoas. Caso os veículos considerados sejam de capacidades não convencionais, será dado também como entrada a capacidade dos veículos, considerando que todos os veículos são iguais.", "Funções e Tipos de dados", ['def test_case_1():\n    assert carros(12) == 3\n', 'def test_case_2():\n    assert carros(1) == 1\n', 'def test_case_3():\n    assert carros(16) == 4\n', 'def test_case_4():\n    assert carros(3, 1) == 3\n', 'def test_case_5():\n    assert carros(1, 3) == 1\n', 'def test_case_6():\n    assert carros(16, 6) == 3\n', 'def test_case_7():\n    assert carros(14, 4) == 4\n', 'def test_case_8():\n    assert carros(11, 6) == 2\n', 'def test_case_9():\n    assert carros(0) == 0\n', 'def test_case_10():\n    assert carros(5) == 1\n']])
    # data_array.append(["def bolo(a: int,b: int,c: int) -> int:\n    return min(a//2,b//3,c//5)\n", "*Questão OBI (Olimpíada Brasileira de Informática - OBI2012, Fase 2, Nível Júnior) - (Receita de Bolo)*\n\nJoão deseja fazer bolos para seus amigos, usando uma receita que indica que devem ser usadas 2 xícaras de farinha de trigo, 3 ovos e 5 colheres de sopa de leite.\nEm casa ele tem **A** xícaras de farinha de trigo, **B** ovos e **C** colheres de sopa de leite. João não tem muita prática com a cozinha, e portanto ele só se arriscará a\nfazer medidas exatas da receita de bolo (por exemplo, se ele tiver material suficiente para fazer mais do que 2 e menos do que 3 bolos, ele fará somente 2 bolos). \nSabendo disto, ajude João escrevendo uma função chamada **bolos** que determine qual a quantidade máxima de bolos que ele consegue fazer.\n\n- **Entrada:** Os parâmetros de entrada da função são três números inteiros A, B e C, indicando respectivamente o número de xícaras de farinha de trigo, o número de ovos e o número de colheres de sopa de leite que João tem em casa.\n\n- **Saída:** Sua função deve retornar a quantidade máxima de bolos que João consegue fazer.\n\nExemplos:\n\n- Entrada: 4, 6, 10;\nSaída: 2\n- Entrada: 4, 6, 9 ;\nSaída: 1'", "Funcoes e Tipos de dados", ['def test_case_1():\n    assert bolo(2, 50, 3) == 0\n', 'def test_case_2():\n    assert bolo(2, 3, 5) == 1\n', 'def test_case_3():\n    assert bolo(6, 9, 15) == 3\n', 'def test_case_4():\n    assert bolo(2, 6, 50) == 1\n', 'def test_case_5():\n    assert bolo(20, 15, 500) == 5\n', 'def test_case_6():\n    assert bolo(20, 15, 10) == 2\n', 'def test_case_7():\n    assert bolo(4, 6, 10) == 2\n', 'def test_case_8():\n    assert bolo(4, 6, 9) == 1\n', 'def test_case_9():\n    assert bolo(0, 5, 5) == 0\n', 'def test_case_10():\n    assert bolo(10, 1, 5) == 0\n']])
    
    # 03 - Tipos de dados, Strings, Estrutura Condicional
    # data_array.append(["def PosNegZero(x: int) -> str:\n    if x > 0:\n        return str(x) + ' e positivo'\n    if x < 0:\n        return str(x) + ' e negativo'\n    return str(x) + ' e zero'\n", "Faça uma função chamada PosNegZero que determina se um número inteiro X passado como parâmetro é positivo, negativo ou zero. O valor de retorno da função deve ser uma dentre as strings “X e positivo”, “X e negativo” ou “X e zero”.", "Tipos de dados, Strings, Estrutura Condicional", ["def test_case_1():\n    assert PosNegZero(51) == '51 e positivo'\n", "def test_case_2():\n    assert PosNegZero(-71) == '-71 e negativo'\n", "def test_case_3():\n    assert PosNegZero(-45) == '-45 e negativo'\n", "def test_case_4():\n    assert PosNegZero(-47) == '-47 e negativo'\n", "def test_case_5():\n    assert PosNegZero(44) == '44 e positivo'\n", "def test_case_6():\n    assert PosNegZero(-27) == '-27 e negativo'\n", "def test_case_7():\n    assert PosNegZero(-4) == '-4 e negativo'\n", "def test_case_8():\n    assert PosNegZero(71) == '71 e positivo'\n", "def test_case_9():\n    assert PosNegZero(12) == '12 e positivo'\n", "def test_case_10():\n    assert PosNegZero(73) == '73 e positivo'\n", "def test_case_11():\n    assert PosNegZero(30) == '30 e positivo'\n", "def test_case_12():\n    assert PosNegZero(-66) == '-66 e negativo'\n", "def test_case_13():\n    assert PosNegZero(-49) == '-49 e negativo'\n", "def test_case_14():\n    assert PosNegZero(-23) == '-23 e negativo'\n", "def test_case_15():\n    assert PosNegZero(18) == '18 e positivo'\n", "def test_case_16():\n    assert PosNegZero(50) == '50 e positivo'\n", "def test_case_17():\n    assert PosNegZero(40) == '40 e positivo'\n", "def test_case_18():\n    assert PosNegZero(-26) == '-26 e negativo'\n", "def test_case_19():\n    assert PosNegZero(-16) == '-16 e negativo'\n", "def test_case_20():\n    assert PosNegZero(-73) == '-73 e negativo'\n", "def test_case_21():\n    assert PosNegZero(-75) == '-75 e negativo'\n", "def test_case_22():\n    assert PosNegZero(3) == '3 e positivo'\n", "def test_case_23():\n    assert PosNegZero(-75) == '-75 e negativo'\n", "def test_case_24():\n    assert PosNegZero(10) == '10 e positivo'\n", "def test_case_25():\n    assert PosNegZero(31) == '31 e positivo'\n", "def test_case_26():\n    assert PosNegZero(6) == '6 e positivo'\n", "def test_case_27():\n    assert PosNegZero(51) == '51 e positivo'\n", "def test_case_28():\n    assert PosNegZero(28) == '28 e positivo'\n", "def test_case_29():\n    assert PosNegZero(47) == '47 e positivo'\n", "def test_case_30():\n    assert PosNegZero(48) == '48 e positivo'\n", "def test_case_31():\n    assert PosNegZero(34) == '34 e positivo'\n", "def test_case_32():\n    assert PosNegZero(43) == '43 e positivo'\n", "def test_case_33():\n    assert PosNegZero(28) == '28 e positivo'\n", "def test_case_34():\n    assert PosNegZero(38) == '38 e positivo'\n", "def test_case_35():\n    assert PosNegZero(-74) == '-74 e negativo'\n", "def test_case_36():\n    assert PosNegZero(14) == '14 e positivo'\n", "def test_case_37():\n    assert PosNegZero(14) == '14 e positivo'\n", "def test_case_38():\n    assert PosNegZero(24) == '24 e positivo'\n", "def test_case_39():\n    assert PosNegZero(21) == '21 e positivo'\n", "def test_case_40():\n    assert PosNegZero(41) == '41 e positivo'\n", "def test_case_41():\n    assert PosNegZero(76) == '76 e positivo'\n", "def test_case_42():\n    assert PosNegZero(-79) == '-79 e negativo'\n", "def test_case_43():\n    assert PosNegZero(64) == '64 e positivo'\n", "def test_case_44():\n    assert PosNegZero(-28) == '-28 e negativo'\n", "def test_case_45():\n    assert PosNegZero(-67) == '-67 e negativo'\n", "def test_case_46():\n    assert PosNegZero(-64) == '-64 e negativo'\n", "def test_case_47():\n    assert PosNegZero(49) == '49 e positivo'\n", "def test_case_48():\n    assert PosNegZero(0) == '0 e zero'\n", "def test_case_49():\n    assert PosNegZero(-27) == '-27 e negativo'\n", "def test_case_50():\n    assert PosNegZero(8) == '8 e positivo'\n", "def test_case_51():\n    assert PosNegZero(-43) == '-43 e negativo'\n"]])
    # data_array.append(["def classificacao(Cv: int, Ce: int, Cs: int, Fv: int, Fe: int, Fs: int) -> str:\n    if Cv * 3 + Ce > Fv * 3 + Fe:\n        return 'Cormengo'\n    if Cv * 3 + Ce < Fv * 3 + Fe:\n        return 'Flaminthians'\n    if Cs > Fs:\n        return 'Cormengo'\n    if Cs < Fs:\n        return 'Flaminthians'\n    return 'Empate'\n", "Dois times, Cormengo e Flaminthians, participam de um campeonato de futebol, juntamente com outros times. Cada vitória conta três pontos, cada empate um ponto. Fica melhor classificado no campeonato um time que tenha mais pontos. Em caso de empate no número de pontos, fica melhor classificado o time que tiver maior saldo de gols. Se o número de pontos e o saldo de gols forem os mesmos para os dois times então os dois times estão empatados no campeonato. Faça uma função definida por classificacao(Cv, Ce, Cs, Fv, Fe, Fs). Dados os números de vitórias e empates, e os saldos de gols dos dois times, sua tarefa é determinar qual dos dois está melhor classificado, ou se eles estão empatados no campeonato.Entrada: Os parâmetros de entrada da função são seis números inteiros C, Ce, Cs, F v, F e e F s, que são, respectivamente, o número de vitórias do Cormengo, o número de empates do Cormengo, o saldo de gols do Cormengo, o número de vitórias do Flaminthians, o número de empates do Flaminthians e o saldo de gols do Flaminthians. Saída: A sua fun¸ção deve retornar a string 'Cormengo', se Cormengo estiver melhor classificado que Flaminthians ou a string 'Flaminthians' , se Flaminthians estiver melhor classificado que Cormengo; e se os dois times estão empatados a função deve retornar 'Empate'. Exemplos: Entrada: 10,5,18,11,2,18 Saída: ’Empate’\nEntrada: 10,5,18,11,1,18 ; Saída: ’Cormengo’\nEntrada: 9,5,-1,10,2,10 Saída: ’Flaminthians’", "Tipos de dados, Strings, Estrutura Condicional", ["def test_case_1():\n    assert classificacao(9, 5, 6, 18, 5, 0) == 'Flaminthians'\n", "def test_case_2():\n    assert classificacao(5, 6, 6, 9, 19, 7) == 'Flaminthians'\n", "def test_case_3():\n    assert classificacao(9, 2, -3, 9, 2, -3) == 'Empate'\n", "def test_case_4():\n    assert classificacao(11, 13, -8, 10, 12, -9) == 'Cormengo'\n", "def test_case_5():\n    assert classificacao(19, 4, 4, 8, 7, 2) == 'Cormengo'\n", "def test_case_6():\n    assert classificacao(9, 17, 0, 13, 16, 6) == 'Flaminthians'\n", "def test_case_7():\n    assert classificacao(15, 2, 2, 11, 9, 7) == 'Cormengo'\n", "def test_case_8():\n    assert classificacao(18, 7, 9, 9, 6, -5) == 'Cormengo'\n", "def test_case_9():\n    assert classificacao(3, 16, -1, 18, 10, -2) == 'Flaminthians'\n", "def test_case_10():\n    assert classificacao(14, 15, -4, 7, 9, 5) == 'Cormengo'\n", "def test_case_11():\n    assert classificacao(16, 5, -5, 13, 3, -8) == 'Cormengo'\n", "def test_case_12():\n    assert classificacao(18, 6, 6, 2, 54, 6) == 'Empate'\n", "def test_case_13():\n    assert classificacao(16, 2, -2, 19, 3, -3) == 'Flaminthians'\n", "def test_case_14():\n    assert classificacao(6, 2, 6, 2, 14, 6) == 'Empate'\n", "def test_case_15():\n    assert classificacao(10, 19, -5, 8, 25, -9) == 'Cormengo'\n", "def test_case_16():\n    assert classificacao(18, 8, -3, 17, 11, 6) == 'Flaminthians'\n", "def test_case_17():\n    assert classificacao(16, 11, 6, 3, 5, -10) == 'Cormengo'\n", "def test_case_18():\n    assert classificacao(1, 12, 2, 10, 26, 2) == 'Flaminthians'\n", "def test_case_19():\n    assert classificacao(19, 2, -9, 3, 4, 8) == 'Cormengo'\n", "def test_case_20():\n    assert classificacao(17, 6, -2, 10, 27, 8) == 'Flaminthians'\n", "def test_case_21():\n    assert classificacao(16, 4, 6, 16, 4, 6) == 'Empate'\n", "def test_case_22():\n    assert classificacao(0, 27, -9, 2, 21, -9) == 'Empate'\n", "def test_case_23():\n    assert classificacao(12, 5, 9, 13, 2, 4) == 'Cormengo'\n", "def test_case_24():\n    assert classificacao(15, 14, -7, 17, 8, -7) == 'Empate'\n", "def test_case_25():\n    assert classificacao(15, 11, 2, 13, 17, -5) == 'Cormengo'\n", "def test_case_26():\n    assert classificacao(6, 8, -5, 8, 2, 9) == 'Flaminthians'\n", "def test_case_27():\n    assert classificacao(2, 28, -5, 12, 21, -8) == 'Flaminthians'\n", "def test_case_28():\n    assert classificacao(13, 5, -10, 5, 29, 9) == 'Flaminthians'\n", "def test_case_29():\n    assert classificacao(15, 15, 5, 7, 6, -9) == 'Cormengo'\n", "def test_case_30():\n    assert classificacao(2, 20, -9, 14, 5, 8) == 'Flaminthians'\n", "def test_case_31():\n    assert classificacao(14, 2, 0, 17, 14, 0) == 'Flaminthians'\n", "def test_case_32():\n    assert classificacao(18, 8, 6, 3, 11, -5) == 'Cormengo'\n", "def test_case_33():\n    assert classificacao(7, 23, 3, 9, 17, 3) == 'Empate'\n", "def test_case_34():\n    assert classificacao(10, 6, -6, 10, 2, 9) == 'Cormengo'\n", "def test_case_35():\n    assert classificacao(14, 4, 3, 15, 1, 3) == 'Empate'\n", "def test_case_36():\n    assert classificacao(7, 23, 4, 5, 13, 2) == 'Cormengo'\n", "def test_case_37():\n    assert classificacao(4, 19, 4, 6, 13, 4) == 'Empate'\n", "def test_case_38():\n    assert classificacao(5, 16, 2, 1, 10, 8) == 'Cormengo'\n", "def test_case_39():\n    assert classificacao(10, 18, 7, 9, 21, 7) == 'Empate'\n", "def test_case_40():\n    assert classificacao(8, 8, -8, 7, 11, -8) == 'Empate'\n", "def test_case_41():\n    assert classificacao(11, 5, 9, 16, 2, 7) == 'Flaminthians'\n", "def test_case_42():\n    assert classificacao(14, 12, 3, 13, 15, 3) == 'Empate'\n", "def test_case_43():\n    assert classificacao(1, 9, 0, 1, 11, -10) == 'Flaminthians'\n", "def test_case_44():\n    assert classificacao(16, 4, -3, 15, 7, -3) == 'Empate'\n", "def test_case_45():\n    assert classificacao(8, 8, -10, 13, 13, 4) == 'Flaminthians'\n", "def test_case_46():\n    assert classificacao(12, 18, 0, 11, 14, 8) == 'Cormengo'\n", "def test_case_47():\n    assert classificacao(18, 2, 0, 13, 17, 0) == 'Empate'\n", "def test_case_48():\n    assert classificacao(5, 5, 4, 3, 11, 9) == 'Flaminthians'\n", "def test_case_49():\n    assert classificacao(15, 1, -2, 11, 13, -2) == 'Empate'\n", "def test_case_50():\n    assert classificacao(6, 18, 9, 9, 9, 9) == 'Empate'\n"]])
    # data_array.append(["def avioes(competidores: int, quantidadePapel: int, quantidadeFolhas: int) -> str:\n    if quantidadePapel//(competidores*quantidadeFolhas) == 0:\n        return 'Insuficiente'\n    return 'Suficiente'\n", "Para descontrair os alunos após as provas da OBI, a Diretora da escola organizou um campeonato de aviões de papel. Cada aluno participante receberá uma certa quantidade de folhas de um papel especial para fazer os seus modelos de aviões. A quantidade de folhas que cada aluno deverá receber ainda não foi determinada: ela será decidida pelos juízes do campeonato. A diretora convidou, para atuarem como juízes, engenheiros da Embraer, uma das mais bem sucedidas empresas brasileiras, que vende aviões com tecnologia brasileira no mundo todo. O campeonato está programado para começar logo após a prova da OBI, mas os juízes ainda não chegaram à escola. A diretora está aflita, pois comprou uma boa quantidade de folhas de papel especial, mas não sabe se a quantidade comprada vai ser suficiente. Considere, por exemplo, que a Diretora comprou 100 folhas de papel especial, e que há 33 competidores. Se os juízes decidirem que cada competidor tem direito a três folhas de papel, a quantidade comprada pela diretora é suficiente. Mas se os juízes decidirem que cada competidor tem direito a quatro folhas, a quantidade comprada pela diretora não seria suficiente. Você deve escrever uma função definida por avioes(competidores, papel comprado, papel competidor) que, dados o número de competidores, o número de folhas de papel especial compradas pela Diretora e o número de folhas que cada competidor deve receber, determine se o número de folhas comprado pela Diretora é suficiente. Entrada: Os parâmetros de entrada da função são três números inteiros representando respectivamente o número de competidores, a quantidade de folhas de papel especial compradas pela Diretora e a quantidade de folhas de papel especial que cada competidor deve receber. Saída: A sua função deve retornar 'Suficiente' se a quantidade de folhas compradas pela Diretora for suficiente, ou 'Insuficiente' caso contrário. Exemplos: Entrada: 10,100,10 Saída: 'Suficiente'\nEntrada: 10,90,10Saída: 'Insuficiente'\nEntrada: 5,40,2Saída: 'Suficiente'", "Tipos de dados, Strings, Estrutura Condicional", ])
    
    # 04 - Variáveis e atribuição, strings e tuplas
    data_array.append(["def concatenacao(a: str, b: str) -> str:\n\treturn a + b + b + a\n", "Considere que a e b são duas strings à escolha do usuário. Faça uma função, chamada concatenacao, que retorne a concatenação delas no formato abba.", "Variáveis e atribuição, strings e tuplas", ["def test_case_1():\n    assert concatenacao('pintalgar', '') == 'pintalgarpintalgar'\n", "def test_case_2():\n    assert concatenacao('cirzo', 'Mark') == 'cirzoMarkMarkcirzo'\n", "def test_case_3():\n    assert concatenacao('duodecénio', 'somatotropas') == 'duodecéniosomatotropassomatotropasduodecénio'\n", "def test_case_4():\n    assert concatenacao('boateiro', 'anticolérico') == 'boateiroanticoléricoanticoléricoboateiro'\n", "def test_case_5():\n    assert concatenacao('alcatraz', 'gauchai') == 'alcatrazgauchaigauchaialcatraz'\n", "def test_case_6():\n    assert concatenacao('carcereiro', 'europeízem') == 'carcereiroeuropeízemeuropeízemcarcereiro'\n", "def test_case_7():\n    assert concatenacao('trajo', 'espaldar') == 'trajoespaldarespaldartrajo'\n", "def test_case_8():\n    assert concatenacao('Lérida', 'convêm') == 'LéridaconvêmconvêmLérida'\n", "def test_case_9():\n    assert concatenacao('panelada', ' ') == 'panelada  panelada'\n", "def test_case_10():\n    assert concatenacao('nevoeirada', 'predilecção') == 'nevoeiradapredilecçãopredilecçãonevoeirada'\n", "def test_case_11():\n    assert concatenacao('multimédia', 'subtractivo') == 'multimédiasubtractivosubtractivomultimédia'\n", "def test_case_12():\n    assert concatenacao('cobiçoso', 'penúltimo') == 'cobiçosopenúltimopenúltimocobiçoso'\n", "def test_case_13():\n    assert concatenacao('cólico', 'linguístico') == 'cólicolinguísticolinguísticocólico'\n", "def test_case_14():\n    assert concatenacao('caleira', 'fanático') == 'caleirafanáticofanáticocaleira'\n", "def test_case_15():\n    assert concatenacao('persecução', 'esticanço') == 'persecuçãoesticançoesticançopersecução'\n", "def test_case_16():\n    assert concatenacao('crápula', 'generante') == 'crápulagenerantegenerantecrápula'\n", "def test_case_17():\n    assert concatenacao(' ', 'musicologia') == ' musicologiamusicologia '\n", "def test_case_18():\n    assert concatenacao('', 'segue') == 'seguesegue'\n", "def test_case_19():\n    assert concatenacao('lamentar', 'Lérida') == 'lamentarLéridaLéridalamentar'\n", "def test_case_20():\n    assert concatenacao('somatotropas', 'repelir') == 'somatotropasrepelirrepelirsomatotropas'\n", "def test_case_21():\n    assert concatenacao('sustivéreis', 'caleira') == 'sustivéreiscaleiracaleirasustivéreis'\n", "def test_case_22():\n    assert concatenacao('arborista', 'sigilar') == 'arboristasigilarsigilararborista'\n"]])
    data_array.append(["def substitui(s: str,x: str,i: int) -> str:\n    if i < 0 or i >= len(s):\n        return 'i inválido'\n    return s[:i] + x + s[i+1:]\n", "Escreva uma função definida por substitui(s, x, i) que receba uma string s, um caractere x e um número inteiro i  entre 0 e o comprimento da string, e retorne uma string igual a s, exceto que o elemento da posição i  deve ser substituído pelo caractere x.", "Variáveis e atribuição, strings e tuplas", ["def test_case_1():\n    assert substitui('pintalgar', 'x', 2) == 'pixtalgar'\n", "def test_case_2():\n    assert substitui('crestar', 'l', 4) == 'creslar'\n", "def test_case_3():\n    assert substitui('anticolérico', 'j', 11) == 'anticoléricj'\n", "def test_case_4():\n    assert substitui('repelir', 't', 1) == 'rtpelir'\n", "def test_case_5():\n    assert substitui('intravável', 'x', 5) == 'intraxável'\n", "def test_case_6():\n    assert substitui('bit', 'j', 0) == 'jit'\n", "def test_case_7():\n    assert substitui('saberdes', 'e', 5) == 'saberees'\n", "def test_case_8():\n    assert substitui('fanático', 'x', 7) == 'fanáticx'\n", "def test_case_9():\n    assert substitui('vagão', 'e', 3) == 'vageo'\n", "def test_case_10():\n    assert substitui('somatotropas', 'l', 6) == 'somatolropas'\n", "def test_case_11():\n    assert substitui('convêm', 'v', 3) == 'convêm'\n", "def test_case_12():\n    assert substitui('gauchai', 'v', 3) == 'gauvhai'\n", "def test_case_13():\n    assert substitui('alcatraz', 'l', 7) == 'alcatral'\n", "def test_case_14():\n    assert substitui('dúbio', 't', 2) == 'dútio'\n", "def test_case_15():\n    assert substitui('humildade', 'y', 5) == 'humilyade'\n", "def test_case_16():\n    assert substitui('voraz', 'k', 3) == 'vorkz'\n", "def test_case_17():\n    assert substitui('cabular', 'c', 3) == 'cabclar'\n", "def test_case_18():\n    assert substitui('equitativo', 'i', 7) == 'equitativo'\n", "def test_case_19():\n    assert substitui('entretendo', 'k', 7) == 'entretekdo'\n", "def test_case_20():\n    assert substitui('amoladura', 'u', 4) == 'amoludura'\n", "def test_case_21():\n    assert substitui('escorrer', 'i', 7) == 'escorrei'\n", "def test_case_22():\n    assert substitui('arborista', 'p', 1) == 'apborista'\n", "def test_case_23():\n    assert substitui('boateiro', 'g', 6) == 'boateigo'\n", "def test_case_24():\n    assert substitui('filonianos', 'b', 9) == 'filonianob'\n", "def test_case_25():\n    assert substitui('trajo', 'f', 4) == 'trajf'\n", "def test_case_26():\n    assert substitui('ressentir', 'p', 4) == 'resspntir'\n", "def test_case_27():\n    assert substitui('intercelular', 'c', 11) == 'intercelulac'\n", "def test_case_28():\n    assert substitui('persecução', 'w', 9) == 'persecuçãw'\n", "def test_case_29():\n    assert substitui('sustiveram', 'o', 0) == 'oustiveram'\n", "def test_case_30():\n    assert substitui('arpear', 'o', 2) == 'aroear'\n", "def test_case_31():\n    assert substitui('drogaria', 'f', 5) == 'drogafia'\n", "def test_case_32():\n    assert substitui('duodecénio', 't', 2) == 'dutdecénio'\n", "def test_case_33():\n    assert substitui('penúltimo', 'w', 4) == 'penúwtimo'\n", "def test_case_34():\n    assert substitui('adviéreis', 'l', 1) == 'alviéreis'\n", "def test_case_35():\n    assert substitui('Kennedy', 'g', 2) == 'Kegnedy'\n", "def test_case_36():\n    assert substitui('lamentar', 'g', 3) == 'lamgntar'\n", "def test_case_37():\n    assert substitui('imperturbado', 'w', 1) == 'iwperturbado'\n", "def test_case_38():\n    assert substitui('higienizar', 'j', 4) == 'higijnizar'\n", "def test_case_39():\n    assert substitui('terreno', 'z', 6) == 'terrenz'\n", "def test_case_40():\n    assert substitui('cólico', 't', 5) == 'cólict'\n", "def test_case_41():\n    assert substitui('vivificativo', 'c', 0) == 'civificativo'\n", "def test_case_42():\n    assert substitui('segue', 'q', 3) == 'segqe'\n", "def test_case_43():\n    assert substitui('paludismo', 'c', 7) == 'paludisco'\n", "def test_case_44():\n    assert substitui('multimédia', 'i', 2) == 'muitimédia'\n", "def test_case_45():\n    assert substitui('cacheiro', 'u', 1) == 'cucheiro'\n", "def test_case_46():\n    assert substitui('inclusão', 'p', 6) == 'incluspo'\n", "def test_case_47():\n    assert substitui('lixoso', 'x', 4) == 'lixoxo'\n", "def test_case_48():\n    assert substitui('luso', 'k', 2) == 'luko'\n", "def test_case_49():\n    assert substitui('confessor', 'x', 4) == 'confxssor'\n", "def test_case_50():\n    assert substitui('divindade', 'i', 8) == 'divindadi'\n", "def test_case_51():\n    assert substitui('borbulhento', 'r', 6) == 'borbulrento'\n", "def test_case_52():\n    assert substitui('particularista', 'l', 2) == 'palticularista'\n", "def test_case_53():\n    assert substitui('sigilar', 'w', 6) == 'sigilaw'\n", "def test_case_54():\n    assert substitui('matutar', 'u', 6) == 'matutau'\n", "def test_case_55():\n    assert substitui('regresso', 'm', 6) == 'regresmo'\n", "def test_case_56():\n    assert substitui('generante', 'l', 0) == 'lenerante'\n", "def test_case_57():\n    assert substitui('caleira', 's', 0) == 'saleira'\n", "def test_case_58():\n    assert substitui('cirzo', 's', 2) == 'ciszo'\n", "def test_case_59():\n    assert substitui('nevoeirada', 'l', 6) == 'nevoeilada'\n", "def test_case_60():\n    assert substitui('delirar', 'f', 1) == 'dflirar'\n", "def test_case_61():\n    assert substitui('previne', 'h', 2) == 'prhvine'\n", "def test_case_62():\n    assert substitui('Mussolini', 'h', 3) == 'Musholini'\n", "def test_case_63():\n    assert substitui('Mark', 'l', 2) == 'Malk'\n", "def test_case_64():\n    assert substitui('sustivéreis', 'h', 4) == 'susthvéreis'\n", "def test_case_65():\n    assert substitui('exultar', 'u', 0) == 'uxultar'\n", "def test_case_66():\n    assert substitui('advirdes', 'b', 6) == 'advirdbs'\n", "def test_case_67():\n    assert substitui('traziam', 'e', 3) == 'traeiam'\n", "def test_case_68():\n    assert substitui('sagaz', 'b', 1) == 'sbgaz'\n", "def test_case_69():\n    assert substitui('cagaçal', 'i', 1) == 'cigaçal'\n", "def test_case_70():\n    assert substitui('linguístico', 't', 0) == 'tinguístico'\n", "def test_case_71():\n    assert substitui('espaldar', 'x', 1) == 'expaldar'\n", "def test_case_72():\n    assert substitui('Lérida', 'f', 4) == 'Lérifa'\n", "def test_case_73():\n    assert substitui('aborto', 'o', 0) == 'oborto'\n", "def test_case_74():\n    assert substitui('troçar', 'f', 3) == 'trofar'\n", "def test_case_75():\n    assert substitui('carcereiro', 'g', 4) == 'carcgreiro'\n", "def test_case_76():\n    assert substitui('europeízem', 'q', 5) == 'europqízem'\n", "def test_case_77():\n    assert substitui('ogivado', 's', 3) == 'ogisado'\n", "def test_case_78():\n    assert substitui('sorrir', 'o', 1) == 'sorrir'\n", "def test_case_79():\n    assert substitui('musicologia', 'k', 4) == 'musikologia'\n", "def test_case_80():\n    assert substitui('subtractivo', 'd', 2) == 'sudtractivo'\n", "def test_case_81():\n    assert substitui('famigerado', 'p', 4) == 'famiperado'\n", "def test_case_82():\n    assert substitui('panelada', 'd', 4) == 'panedada'\n", "def test_case_83():\n    assert substitui('festinhas', 'i', 3) == 'fesiinhas'\n", "def test_case_84():\n    assert substitui('esticanço', 'y', 6) == 'esticayço'\n", "def test_case_85():\n    assert substitui('atomismo', 'o', 7) == 'atomismo'\n", "def test_case_86():\n    assert substitui('cobiçoso', 's', 2) == 'cosiçoso'\n", "def test_case_87():\n    assert substitui('virginalizar', 'g', 4) == 'virggnalizar'\n", "def test_case_88():\n    assert substitui('candelabro', 'b', 4) == 'candblabro'\n", "def test_case_89():\n    assert substitui('barão', 'q', 2) == 'baqão'\n", "def test_case_90():\n    assert substitui('crápula', 'g', 2) == 'crgpula'\n", "def test_case_91():\n    assert substitui('séquito', 's', 5) == 'séquiso'\n", "def test_case_92():\n    assert substitui('predilecção', 'n', 9) == 'predilecçno'\n", "def test_case_93():\n    assert substitui('isotónico', 'a', 2) == 'isatónico'\n", "def test_case_94():\n    assert substitui('Schiller', 'k', 0) == 'kchiller'\n", "def test_case_95():\n    assert substitui(' ', 'x', 0) == 'x'\n", "def test_case_96():\n    assert substitui('dragagem', 'o', 5) == 'dragaoem'\n", "def test_case_97():\n    assert substitui('centro', 'i', 1) == 'cintro'\n", "def test_case_98():\n    assert substitui('OGMA', 'z', 2) == 'OGzA'\n", "def test_case_99():\n    assert substitui('destingir', 'o', 8) == 'destingio'\n", "def test_case_100():\n    assert substitui('delínquo', 'o', 2) == 'deoínquo'\n"]])
    data_array.append(["def hashtag(string: str) -> str:\n    pos = len(string)//2\n    return '#' + string[:pos] + '#' + string[pos:] + '#'\n", "Escreva uma função chamada hashtag que receba uma string e insira o caractere ”#” no início, no meio e no final dela. Por exemplo, se a entrada for ”abcd”, a saída deve ser ”#ab#cd#”. Outro exemplo: se receber ”abcde”, a função deve retornar ”#ab#cde#”.", "Variáveis e atribuição, strings e tuplas", ["def test_case_1():\n    assert hashtag('drogaria') == '#drog#aria#'\n", "def test_case_2():\n    assert hashtag('bit') == '#b#it#'\n", "def test_case_3():\n    assert hashtag('troçar') == '#tro#çar#'\n", "def test_case_4():\n    assert hashtag('inclusão') == '#incl#usão#'\n", "def test_case_5():\n    assert hashtag('cobiçoso') == '#cobi#çoso#'\n", "def test_case_6():\n    assert hashtag('musicologia') == '#music#ologia#'\n", "def test_case_7():\n    assert hashtag('delínquo') == '#delí#nquo#'\n", "def test_case_8():\n    assert hashtag('carcereiro') == '#carce#reiro#'\n", "def test_case_9():\n    assert hashtag('europeízem') == '#europ#eízem#'\n", "def test_case_10():\n    assert hashtag('sustivéreis') == '#susti#véreis#'\n", "def test_case_11():\n    assert hashtag('traziam') == '#tra#ziam#'\n", "def test_case_12():\n    assert hashtag('virginalizar') == '#virgin#alizar#'\n", "def test_case_13():\n    assert hashtag('sorrir') == '#sor#rir#'\n", "def test_case_14():\n    assert hashtag('candelabro') == '#cande#labro#'\n", "def test_case_15():\n    assert hashtag('arborista') == '#arbo#rista#'\n", "def test_case_16():\n    assert hashtag('adviéreis') == '#advi#éreis#'\n", "def test_case_17():\n    assert hashtag('ressentir') == '#ress#entir#'\n", "def test_case_18():\n    assert hashtag('festinhas') == '#fest#inhas#'\n", "def test_case_19():\n    assert hashtag('atomismo') == '#atom#ismo#'\n", "def test_case_20():\n    assert hashtag('lamentar') == '#lame#ntar#'\n", "def test_case_21():\n    assert hashtag('anticolérico') == '#antico#lérico#'\n", "def test_case_22():\n    assert hashtag('boateiro') == '#boat#eiro#'\n", "def test_case_23():\n    assert hashtag('sagaz') == '#sa#gaz#'\n", "def test_case_24():\n    assert hashtag('trajo') == '#tr#ajo#'\n", "def test_case_25():\n    assert hashtag('arpear') == '#arp#ear#'\n", "def test_case_26():\n    assert hashtag('repelir') == '#rep#elir#'\n", "def test_case_27():\n    assert hashtag('crestar') == '#cre#star#'\n", "def test_case_28():\n    assert hashtag('espaldar') == '#espa#ldar#'\n", "def test_case_29():\n    assert hashtag('convêm') == '#con#vêm#'\n", "def test_case_30():\n    assert hashtag('intercelular') == '#interc#elular#'\n", "def test_case_31():\n    assert hashtag('borbulhento') == '#borbu#lhento#'\n", "def test_case_32():\n    assert hashtag('cirzo') == '#ci#rzo#'\n", "def test_case_33():\n    assert hashtag('nevoeirada') == '#nevoe#irada#'\n", "def test_case_34():\n    assert hashtag('equitativo') == '#equit#ativo#'\n", "def test_case_35():\n    assert hashtag('segue') == '#se#gue#'\n", "def test_case_36():\n    assert hashtag('exultar') == '#exu#ltar#'\n", "def test_case_37():\n    assert hashtag('a') == '##a#'\n", "def test_case_38():\n    assert hashtag('ogivado') == '#ogi#vado#'\n", "def test_case_39():\n    assert hashtag('famigerado') == '#famig#erado#'\n", "def test_case_40():\n    assert hashtag('confessor') == '#conf#essor#'\n", "def test_case_41():\n    assert hashtag('particularista') == '#particu#larista#'\n", "def test_case_42():\n    assert hashtag('somatotropas') == '#somato#tropas#'\n", "def test_case_43():\n    assert hashtag('esticanço') == '#esti#canço#'\n", "def test_case_44():\n    assert hashtag('centro') == '#cen#tro#'\n", "def test_case_45():\n    assert hashtag('persecução') == '#perse#cução#'\n", "def test_case_46():\n    assert hashtag('delirar') == '#del#irar#'\n", "def test_case_47():\n    assert hashtag('Mark') == '#Ma#rk#'\n", "def test_case_48():\n    assert hashtag('dragagem') == '#drag#agem#'\n", "def test_case_49():\n    assert hashtag('paludismo') == '#palu#dismo#'\n", "def test_case_50():\n    assert hashtag('escorrer') == '#esco#rrer#'\n", "def test_case_51():\n    assert hashtag('gauchai') == '#gau#chai#'\n", "def test_case_52():\n    assert hashtag('lixoso') == '#lix#oso#'\n", "def test_case_53():\n    assert hashtag('generante') == '#gene#rante#'\n", "def test_case_54():\n    assert hashtag('panelada') == '#pane#lada#'\n", "def test_case_55():\n    assert hashtag('voraz') == '#vo#raz#'\n", "def test_case_56():\n    assert hashtag('humildade') == '#humi#ldade#'\n", "def test_case_57():\n    assert hashtag('multimédia') == '#multi#média#'\n", "def test_case_58():\n    assert hashtag('aborto') == '#abo#rto#'\n", "def test_case_59():\n    assert hashtag('Lérida') == '#Lér#ida#'\n", "def test_case_60():\n    assert hashtag('regresso') == '#regr#esso#'\n", "def test_case_61():\n    assert hashtag('isotónico') == '#isot#ónico#'\n", "def test_case_62():\n    assert hashtag('alcatraz') == '#alca#traz#'\n", "def test_case_63():\n    assert hashtag('vivificativo') == '#vivifi#cativo#'\n", "def test_case_64():\n    assert hashtag('cabular') == '#cab#ular#'\n", "def test_case_65():\n    assert hashtag('séquito') == '#séq#uito#'\n", "def test_case_66():\n    assert hashtag('entretendo') == '#entre#tendo#'\n", "def test_case_67():\n    assert hashtag('cólico') == '#cól#ico#'\n", "def test_case_68():\n    assert hashtag('fanático') == '#faná#tico#'\n", "def test_case_69():\n    assert hashtag('intravável') == '#intra#vável#'\n", "def test_case_70():\n    assert hashtag('pintalgar') == '#pint#algar#'\n", "def test_case_71():\n    assert hashtag('vagão') == '#va#gão#'\n", "def test_case_72():\n    assert hashtag('predilecção') == '#predi#lecção#'\n", "def test_case_73():\n    assert hashtag('higienizar') == '#higie#nizar#'\n", "def test_case_74():\n    assert hashtag('crápula') == '#crá#pula#'\n", "def test_case_75():\n    assert hashtag('barão') == '#ba#rão#'\n", "def test_case_76():\n    assert hashtag('sustiveram') == '#susti#veram#'\n", "def test_case_77():\n    assert hashtag('sigilar') == '#sig#ilar#'\n", "def test_case_78():\n    assert hashtag('filonianos') == '#filon#ianos#'\n", "def test_case_79():\n    assert hashtag('Schiller') == '#Schi#ller#'\n", "def test_case_80():\n    assert hashtag('cacheiro') == '#cach#eiro#'\n", "def test_case_81():\n    assert hashtag('advirdes') == '#advi#rdes#'\n", "def test_case_82():\n    assert hashtag('OGMA') == '#OG#MA#'\n", "def test_case_83():\n    assert hashtag('luso') == '#lu#so#'\n", "def test_case_84():\n    assert hashtag('divindade') == '#divi#ndade#'\n", "def test_case_85():\n    assert hashtag('') == '###'\n", "def test_case_86():\n    assert hashtag('Kennedy') == '#Ken#nedy#'\n", "def test_case_87():\n    assert hashtag('imperturbado') == '#impert#urbado#'\n", "def test_case_88():\n    assert hashtag('caleira') == '#cal#eira#'\n", "def test_case_89():\n    assert hashtag('destingir') == '#dest#ingir#'\n", "def test_case_90():\n    assert hashtag('penúltimo') == '#penú#ltimo#'\n", "def test_case_91():\n    assert hashtag('amoladura') == '#amol#adura#'\n", "def test_case_92():\n    assert hashtag('saberdes') == '#sabe#rdes#'\n", "def test_case_93():\n    assert hashtag('Mussolini') == '#Muss#olini#'\n", "def test_case_94():\n    assert hashtag('cagaçal') == '#cag#açal#'\n", "def test_case_95():\n    assert hashtag('duodecénio') == '#duode#cénio#'\n", "def test_case_96():\n    assert hashtag('terreno') == '#ter#reno#'\n", "def test_case_97():\n    assert hashtag('matutar') == '#mat#utar#'\n", "def test_case_98():\n    assert hashtag('linguístico') == '#lingu#ístico#'\n", "def test_case_99():\n    assert hashtag('subtractivo') == '#subtr#activo#'\n", "def test_case_100():\n    assert hashtag('previne') == '#pre#vine#'\n", "def test_case_101():\n    assert hashtag('dúbio') == '#dú#bio#'\n"]])
    data_array.append(["def filtra_pares(t: list[int]):\n    pares = ()\n    if t[0]%2 == 0:\n        pares = pares + (t[0],)\n    if t[1]%2 == 0:\n        pares = pares + (t[1],)\n    if t[2]%2 == 0:\n        pares = pares + (t[2],)\n    if t[3]%2 == 0:\n        pares = pares + (t[3],)\n    return pares\n", "Faça uma função chamada filtra_pares que receba uma tupla com quatro elementos inteiros como parâmetro, e retorne uma nova tupla contendo apenas os elementos pares da tupla original, na mesma ordem em que se encontravam. Esse tipo de operação onde se selecionam elementos de um conjunto inicial que satisfazem uma determinada propriedade é bastante comum em computação, e se chama filtragem.", "Variáveis e atribuição, strings e tuplas", ['def test_case_1():\n    assert filtra_pares([147, 613, 609, 267]) == ()\n', 'def test_case_2():\n    assert filtra_pares([916, 123, 417, 627]) == (916,)\n', 'def test_case_3():\n    assert filtra_pares([146, 563, 249, 270]) == (146, 270)\n', 'def test_case_4():\n    assert filtra_pares([575, 641, 851, 707]) == ()\n', 'def test_case_5():\n    assert filtra_pares([929, 215, 308, 903]) == (308,)\n', 'def test_case_6():\n    assert filtra_pares([628, 885, 14, 34]) == (628, 14, 34)\n', 'def test_case_7():\n    assert filtra_pares([878, -47, 465, 319]) == (878,)\n', 'def test_case_8():\n    assert filtra_pares([37, 705, 599, 636]) == (636,)\n', 'def test_case_9():\n    assert filtra_pares([-40, 698, 538, 408]) == (-40, 698, 538, 408)\n', 'def test_case_10():\n    assert filtra_pares([991, 775, 5, 394]) == (394,)\n', 'def test_case_11():\n    assert filtra_pares([945, 74, 205, 654]) == (74, 654)\n', 'def test_case_12():\n    assert filtra_pares([207, 369, -5, 812]) == (812,)\n']])
    data_array.append(["def colisao(ret1: tuple[int, int], ret2: tuple[int, int]) -> bool:\n    x_esq1, y_inf1, x_dir1, y_sup1 = ret1\n    x_esq2, y_inf2, x_dir2, y_sup2 = ret2\n    if x_dir2 < x_esq1 or x_dir1 < x_esq2:\n        return False\n    if y_sup2 < y_inf1 or y_sup1 < y_inf2:\n        return False\n    return True\n", "Detecção de colisão é uma das operações mais comuns (e importantes) em jogos eletrônicos. O objetivo, basicamente, é verificar se dois objetos quaisquer colidiram, ou seja, se a interseção entre eles é diferente de vazio. Isso pode ser usado para saber se duas naves colidiram, se um monstro bateu numa parede, se um personagem pegou um item, etc.Para facilitar as coisas, muitas vezes os objetos são aproximados por figuras geométricas simples (esferas, paralelepípedos, triângulos etc). Neste problema, os objetos são aproximados por retângulos num plano 2D. Escreva uma função chamada colisao que, dados dois retângulos, determine se eles se interceptam ou não. Cada retângulo é determinado pelas coordenadas x e y de dois de seus vértices diametralmente opostos,  representando a diagonal que vai da esquerda para a direita e de baixo para cima. Os lados de cada retângulo são sempre paralelos aos eixos x e y.Entrada: Os parâmetros de entrada são duas tuplas com quatro valores inteiros cada uma, representando as coordenadas do primeiro retângulo e as coordenadas do segundo retângulo. Saída: A sua função deve retornar o valor booleano True caso haja interseção ou False, caso não haja. ExemplosEntrada: (0,0,1,1), (0,0,1,1) ; Saída: True\nEntrada: (0,0,2,2), (1,1,3,3) ; Saída: True\nEntrada: (0,0,1,1), (2,2,3,3) ; Saída: False", "Variáveis e atribuição, strings e tuplas", ['def test_case_1():\n    assert colisao([6, 5, 8, 7], [6, 2, 7, 5]) == True\n', 'def test_case_2():\n    assert colisao([4, 8, 9, 9], [2, 1, 9, 5]) == False\n', 'def test_case_3():\n    assert colisao([5, 5, 7, 7], [6, 3, 8, 8]) == True\n', 'def test_case_4():\n    assert colisao([1, 5, 4, 8], [5, 6, 8, 9]) == False\n', 'def test_case_5():\n    assert colisao([1, 4, 9, 7], [8, 7, 9, 8]) == True\n']])
    
    # 05 - Manipulação de strings, tuplas e listas
    # data_array.append(["method", "context", "Manipulação de strings, tuplas e listas"])
    # data_array.append(["method", "context", "Manipulação de strings, tuplas e listas"])
    # data_array.append(["method", "context", "Manipulação de strings, tuplas e listas"])
    # data_array.append(["method", "context", "Manipulação de strings, tuplas e listas"])
    # data_array.append(["method", "context", "Manipulação de strings, tuplas e listas"])
    # data_array.append(["method", "context", "Manipulação de strings, tuplas e listas"])
    # data_array.append(["method", "context", "Manipulação de strings, tuplas e listas"])
    
    # 06 - Fatiamento e manipulação de listas
    # data_array.append(["method", "context", "Fatiamento e manipulação de listas"])
    # data_array.append(["method", "context", "Fatiamento e manipulação de listas"])
    # data_array.append(["method", "context", "Fatiamento e manipulação de listas"])
    # data_array.append(["method", "context", "Fatiamento e manipulação de listas"])
    # data_array.append(["method", "context", "Fatiamento e manipulação de listas"])
    # data_array.append(["method", "context", "Fatiamento e manipulação de listas"])
    
    # 07 - Estrutura de repetição com teste de parada: While
    # data_array.append(["method", "context", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["method", "context", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["method", "context", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["method", "context", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["method", "context", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["method", "context", "Estrutura de repetição com teste de parada: While"])
    
    # 08 - Estrutura de repetição iteradora: for
    # data_array.append(["method", "context", "Estrutura de repetição iteradora: for"])
    # data_array.append(["method", "context", "Estrutura de repetição iteradora: for"])
    # data_array.append(["method", "context", "Estrutura de repetição iteradora: for"])
    # data_array.append(["method", "context", "Estrutura de repetição iteradora: for"])
    # data_array.append(["method", "context", "Estrutura de repetição iteradora: for"])
    # data_array.append(["method", "context", "Estrutura de repetição iteradora: for"])
    
    # 09 - Laços aninhados e matrizes
    # data_array.append(["method", "context", "Laços aninhados e matrizes"])
    # data_array.append(["method", "context", "Laços aninhados e matrizes"])
    # data_array.append(["method", "context", "Laços aninhados e matrizes"])
    # data_array.append(["method", "context", "Laços aninhados e matrizes"])
    # data_array.append(["method", "context", "Laços aninhados e matrizes"])
    
    # 05 - Listas e Dicionários
    # data_array.append(["def intercala(lista1: List[int],lista2: List[int]) -> List[int]:\n    lista3 = 6*[0]\n    lista3[::2] = lista1\n    lista3[1::2] = lista2\n    return lista3\n", "Faça uma função chamada definida por **\\`intercala(lista1, lista2)\\`** que dadas duas listas L1 e L2 de tamanho 3, gera uma lista L3 que é formada intercalando os elementos de L1 e L2. \n\n\n\nExemplo:\n\nL1 = [1, 3, 5] e L2 = [2, 4, 6] gera L3 = [1, 2, 3, 4, 5, 6].", "Listas e Dicionários"])
    # data_array.append(["def pontos_por_time(jogos: list[list[str, str, list[int, int]]]) -> dict[str, int]:\n    pontuacao = {}\n    \n    for jogo in jogos:\n        time1 = jogo[0]\n        time2 = jogo[1]\n        if time1 not in pontuacao:\n            pontuacao[time1] = 0\n        if time2 not in pontuacao:\n            pontuacao[time2] = 0\n            \n        resultado = jogo[2]\n        if resultado[0] > resultado[1]:\n            pontuacao[time1] += 3\n        elif resultado[0] < resultado[1]:\n            pontuacao[time2] += 3\n        else:\n            pontuacao[time1] += 1\n            pontuacao[time2] += 1\n            \n    return pontuacao\n", "Faça uma função chamada pontos_por_time  que receba uma lista de dois elementos, onde cada elemento é também uma lista. A lista completa tem informações do número de gols em dois jogos de futebol entre dois times (jogo da ida e jogo da volta), no seguinte formato: [['Cormengo', 'Flamínthians', [1, 0]], ['Flamínthians', 'Cormengo', [2, 2]]].Nesta lista de exemplo, no primeiro jogo entre Cormengo e Flamínthians, o Cormengo fez 1 gol e o Flamínthians não fez gol. Sua função deve retornar um dicionário cujos mapeamentos são: <nome do time>  -> <numero total de pontos na fase>. Os pontos de um time na fase são calculados da seguinte forma: em cada jogo, os times recebem três pontos por vitória e um ponto por empate. Não são atribuídos pontos para derrotas. O total de pontos de uma fase é a soma de pontos dos dois jogos da fase. Na lista de exemplo, o total de pontos do Cormengo é 4 e do Flamínthians é 1.", "Listas e Dicionários"])
    # data_array.append(["def colchao(lista: list[int],H: int,L: int) -> bool:\n    maior = max(L,H)\n    menor = min(L,H)\n    if lista[1] > maior:\n        return False\n    else:\n        if lista[0] > menor:\n            return False\n        else:\n            return True\n", "Questão OBI (Olimpíada Brasileira de Informática - OBI2012, Fase 1, Nível 2) - (Colchão)\n\nJoão está comprando móveis novos para sua casa. Agora é a vez de comprar um colchão novo, de molas, para substituir o colchão velho. As portas de sua casa têm altura H e largura L e existe um colchão que está em promoção com dimensões A × B × C. O colchão tem a forma de um paralelepípedo reto retângulo e João só consegue arrastá-lo através de uma porta com uma de suas faces paralelas ao chão, mas consegue virar e rotacionar o colchão antes de passar pela porta. Entretanto, de nada adianta ele comprar o colchão se ele não passar através das portas de sua casa. Portanto ele quer saber se consegue passar o colchão pelas portas e para isso precisa de sua ajuda. Faça uma função definida por colchao(medidas,H,L) para resolver esse problema, onde medidas é uma lista com os tamanhos inteiros A, B e C, e H e L são os tamanhos inteiros da altura e largura da porta, respectivamente.\nEntrada: Os parâmetros de entrada são uma lista com as dimensões do colchão em centímetros, ordenadas da menor para a maior, e dois inteiros H e L, correspondentes respectivamente a altura e a largura das portas em centímetros.\nSaída: A sua função deve retornar True se o colchão passa pelas portas e False caso contrário.\nExemplos:\nEntrada: [25,120,220], 200, 100 ; Saída: True\nEntrada: [25,205,220], 200, 100 ; Saída: False\nEntrada: [25,200,220], 200, 100 ; Saída: True", "Listas e Dicionários"])
    
    # (DES) 08 - Estrutura de Repetição - for
    # data_array.append(["def soma_h(n: int) -> float:\n    soma = 0\n    for denominador in range(1,n+1):\n        soma += 1.0/denominador\n    return round(soma,2)", "Faça uma função chamada soma_h para calcular e retornar o valor H com N termos onde N é inteiro e dado com entrada. Retorne seu resultado somente com 2 casas decimais, utilizando a função round(número, 2)", "Estrutura de repetição iteradora: for"])
    # data_array.append(["def divisores(n: int) -> int:\n    total = 0\n    for contador in range(1,n+1):\n        if n%contador == 0:\n            total += 1\n    return total", "Faça uma função chamada divisores que conte quantos divisores um número tem. Este número será passado como argumento de entrada. Exemplo: Se o número for 10, os divisores são: 1, 2, 5 e 10; total de 4 divisores.", "Estrutura de repetição iteradora: for"])
    # data_array.append(["def freq_palavras(frase: str) -> dict:\n    if not re.fullmatch(\"((another)|(value)|(test)| )*\", frase):\n        return None\n    dic = {}\n    lista = frase.split()\n    for palavra in lista:\n        if palavra in dic:\n            dic[palavra] += 1\n        else:\n            dic[palavra] = 1\n    return dic\n", "Construa uma função chamada **freq_palavras(frases)** que receba uma string e retorne um dicionário onde cada palavra dessa string seja uma chave e tenha como valor o número de vezes que a palavra aparece. Por exemplo: \n\n- freq_palavras(\"dinheiro é dinheiro e vice versa\") \n\nRetorna o dicionário: { \"dinheiro\":2, \"é\": 1, \"e\": 1, \"vice\": 1, \"versa\":1}", "Estrutura de repetição iteradora: for"])
    # data_array.append(["def lingua_p(palavra: str) -> str:\n    palavra = str.lower(palavra)\n    traduzida = ''\n    for c in palavra:\n        traduzida = traduzida + c\n        if c in 'aeiouáàãâéêíóòõú':\n            traduzida = traduzida + 'p' + c\n    return traduzida\n", "Faça uma função chamada lingua_p que receba como parâmetro uma palavra e retorne esta mesma palavra traduzida para a lingua do P. Uma palavra é traduzida para a lingua do P quando, após cada vogal da palavra original, é inserida a sequencia de letras p mais a vogal original.\n\nPor exemplo:\n\nexemplo → epexepemplopo\n\nentao → epentapaopo\n\ncaderno → capadepernopo", "Estrutura de repetição iteradora: for"])
    # data_array.append(["def count(frase: str, letra: str) -> int:\n    contador = 0\n    for l in frase.lower():\n        if letra == l:\n            contador += 1\n    return contador", "Faça uma função chamada count  que dada uma frase e uma letra, conte quantas vezes aquela letra aparece na frase, só que sem usar a função count()\nAtenção!Maiúsculas e minúsculas também contam! Mas o computador não sabe que elas são iguais, você precisa antes transformá-las!", "Estrutura de repetição iteradora: for"])
    
    # data_array.append(["def fatorial(n: int) -> int:\n    fat = 1\n    while n>0:\n        fat = fat*n\n        n = n-1\n    return fat\n", "Faça uma função chamada **fatorial** que dado um número, calcule o fatorial deste número. (Não usar a função factorial do módulo math)", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["def posLetra(frase: str, letra: str, ocorrencia: int) -> int:\n    pos = 0\n    contador = 0\n    while pos < len(frase):\n        if frase[pos] == letra:\n            contador = contador + 1\n            if contador == ocorrencia:\n                return pos\n        pos = pos + 1\n    return 'Ocorrência não encontrada'\n", "Faça uma função chamada **posLetra** que recebe como entrada uma string, uma letra, e um número que indica a ocorrência desejada da letra (1 para primeira ocorrência, 2 para segunda, etc). Sua função deve retornar em que posição da string aquela ocorrência da letra está. Caso exista menos ocorrências da letra do que a ocorrência pedida, a função deve mostrar a mensagem \"Ocorrência não encontrada\".\n\nExemplo:\n\n>>> posLetra(\"mariana come banana\", \'a\', 3)\n\n6\n\n(posição da terceira ocorrência da letra \'a\' na string dada)", "Estrutura de repetição com teste de parada: While"])
    # data_array.append(["def faltante(pecas: List[int]) -> int:\n    lp = pecas[:]\n    lp.sort()\n    contador = 0\n    peca = -1\n    while (contador < len(lp)):\n        if (lp[contador] == (contador + 1)):\n            contador = contador + 1\n        else:\n            peca = contador + 1\n            contador = len(lp)\n    if (peca == -1):\n        peca = len(lp) + 1\n    return peca\n", "*Questão OBI (Olimpíada Brasileira de Informática - OBI2007, Fase 1, Nível 1) - (Peça Perdida)*\n\nJoãozinho adora quebra-cabeças, essa é sua brincadeira favorita. O grande problema, porém, é que às vezes o jogo vem com uma peça faltando. Isso irrita bastante o pobre menino, que tem de descobrir qual peça está faltando e solicitar uma peça de reposição ao fabricante do jogo. Sabendo que o quebra-cabeças tem N peças, numeradas de 1 a N e que exatamente uma está faltando, ajude Joãozinho a saber qual peça ele tem de pedir.\n\nEscreva uma função chamada **faltante** que, dada uma lista com N − 1 inteiros numerados de 1 a N, descubra qual número inteiro deste intervalo está faltando.\n\n- **Entrada:** O parâmetro de entrada é uma lista L de tamanho N − 1 contendo números inteiros (não repetidos) de 1 a N.\n- **Saída:** A sua função deve retornar o número inteiro x que pertence ao intervalo [1, N] mas que não pertence a lista de entrada L.\n\nExemplos:\n\n- Entrada: [3,1];\nSaída: 2\n- Entrada: [1,2,3,5] ;\nSaída: 4\n- Entrada: [2,4,3] ;\nSaída: 1", "Estrutura de repetição com teste de parada: While"])
    
    # data_array.append(["def total(compras: List[int], produtos: Dict[str, float]) -> float:\n    soma = 0\n    for produto in compras:\n        if produto in produtos:\n            soma += produtos[produto]\n    return round(soma,2)", "Escreva uma função chamada total que recebe uma lista de compras e um dicionário contendo o preço de cada produto disponível em uma determinada loja, e retorna o valor total dos itens da lista que estejam disponíveis nesta loja. Por exemplo, para os dados:\nlista de compras = [’biscoito’, ’chocolate’, ’farinha’]\nprodutos = { ’amaciante’:4.99, ’arroz’:10.90, ’biscoito’:1.69, ’cafe’:6.98, ’chocolate’:3.79, ’farinha’:2.99 } \nO valor retornado pela função será 8.47. Retorne seu resultado somente com 2 casas decimais, utilizando a função round(número, 2).", "Dicionário"])
    # data_array.append(["def insere(lista: List[int], n: int) -> List[int]:\n    lista=lista+[n]\n    return sorted(lista)", "Faça uma função definida por insere(lista_numero, n) que dada uma lista ordenada (crescente) de números inteiros e um número inteiro n, inclua n na posição correta. Retorne a lista atualizada.", "Listas"])
    # data_array.append(["def maiores(lista: List[int], n: int):\n    lista = lista+[n]\n    list.sort(lista)\n    list.reverse(lista)\n    indice=list.index(lista,n)\n    sublista=lista[:indice]\n    list.sort(sublista)\n    list.reverse(sublista)\n    return str(sublista)", "Faça uma função chamada maiores que dada uma lista ordenada L (decrescente) de números inteiros e um número inteiro n, retorne a sublista formada por todos os elementos maiores que n em ordem decrescente.", "Listas"])
    
    
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    # data_array.append(["method", "context", "theme"])
    return data_array